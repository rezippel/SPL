;;; -*- mode:lisp; package: WRMI; base:10; lowercase:t; syntax:common-lisp -*-
;;; ===========================================================================
;;;			Pretty Printer
;;; ===========================================================================
;;; (c) copyright 1993 Cornell University

;;; $id: upolynomial.lisp,v 2.11 1992/05/15 15:55:08 rz exp $

(in-package "WRMI")

;; This file contains a pretty printer extensions for the code expressions
;; introduced in walker.lisp.  

(defvar *OLD-pprint-dispatch* *print-pprint-dispatch*)
(defvar *SPL-pprint-dispatch* (copy-pprint-dispatch))

;; Since SPL programs are not lists, but objects, we can use method
;; dispatch to decide which program fragment to use to pretty-print an
;; expression.  Thus we only need one form. 

(defun spl-print (form &optional (stream *standard-output*))
  (let ((*print-pprint-dispatch* *SPL-pprint-dispatch*))
    (pprint form stream)))

(defmacro def-pretty-print (name (arg) &body body)
  (let ((pprint-name (intern (format nil "PPRINT-~A" name))))
    `(progn
       (defun ,pprint-name (*standard-output* ,arg) ,@body)
       (set-pprint-dispatch ',name ',pprint-name 0 *SPL-pprint-dispatch*))))

#+ignore
(def-pretty-print variable (form)
  (write (name-of form)))

(def-pretty-print application (form)
  (pprint-logical-block (*standard-output* (args-of form)
                                           :prefix "(" :suffix ")")
    (write (funct-of form))
    (loop (pprint-exit-if-list-exhausted)
	  (write-char #\space)
	  (write (pprint-pop)))))

(def-pretty-print conditional (form)
  (pprint-logical-block (*standard-output* nil :prefix "(" :suffix ")")
    (write-string "IF")
    (write-char #\Space)
    (write (predicate-of form))
    (write-char #\Space)
    (pprint-newline :mandatory)
    (write-string "   ")
    (write (succeed-of form))
    (when (fail-of form)
      (write-char #\Space)
      (pprint-newline :mandatory)
      (write-string "   ")
      (write (fail-of form)))))

(def-pretty-print sequence (form)
  (pprint-logical-block (*standard-output* (terms-of form)
                                           :prefix "(" :suffix ")")
    (write-string "SEQUENCE")
    (write-char #\Space)
    (let ((need-newline? t)
	  (term-indent 1))
      (loop for term in (terms-of form)
	    do (when (typep term 'label)
		 (setq term-indent 8)))      
      (loop for term = (pprint-pop)
	    do (cond ((typep term 'label)
		      (pprint-indent :block 1)
		      (pprint-newline :linear)
		      (write term)
		      (write-char #\:)
		      (loop for i below (- 6 (length (string (name-of term))))
			    do (write-char #\Space))
		      (setq need-newline? nil))
		     (t (pprint-indent :block term-indent)
			(when need-newline?
			  (pprint-newline :mandatory))
			(write term)
			(setq need-newline? t)))
            (pprint-exit-if-list-exhausted)))))

(def-pretty-print label (form)
  (write (name-of form)))

(def-pretty-print goto (form)
  (format *standard-output* "(GO ~A)" (target-of form)))

(def-pretty-print assignment (form)  
  (pprint-logical-block (*standard-output* nil :prefix "(" :suffix ")")
    (write (location-of form))
    (write-char #\Space)
    (write-string "<-")
    (write-char #\Space)
    (write (value-of form))))

(def-pretty-print constrain (form)
  (pprint-logical-block (*standard-output* nil :prefix "(" :suffix ")")
    (write 'CONSTRAIN)
    (write-char #\Space)
    (pprint-logical-block (*standard-output* (vars-of form)
					     :prefix "(" :suffix ")")
      (loop (write (pprint-pop))
	    (pprint-exit-if-list-exhausted)
	    (write-char #\,)
	    (write-char #\Space)
	    (pprint-newline :linear)))
    (write-char #\Space)
    (pprint-indent :block 5)
    (pprint-newline :linear)
    (pprint-logical-block (*standard-output* (constraints-of form)
                                             :prefix "(" :suffix ")")
      (loop (write (pprint-pop))
	    (pprint-exit-if-list-exhausted)
	    (write-char #\,)
	    (write-char #\Space)
	    (pprint-newline :linear)))
    (pprint-indent :block 1)
    (pprint-newline :mandatory)
    (write (term-of form))))

(def-pretty-print extremize (form)
  (pprint-logical-block (*standard-output* nil :prefix "(" :suffix ")")
    (write (if (typep form 'minimize) 'minimize 'maximize))
    (write-char #\Space)
    (pprint-logical-block (*standard-output* (vars-of form)
					     :prefix "(" :suffix ")")
      (loop (write (pprint-pop))
	    (pprint-exit-if-list-exhausted)
	    (write-char #\,)
	    (write-char #\Space)
	    (pprint-newline :linear)))
    (write-char #\Space)
    (pprint-indent :block 5)
    (pprint-newline :linear)
    (pprint-logical-block (*standard-output* (expressions-of form)
                                             :prefix "(" :suffix ")")
      (loop (write (pprint-pop))
	    (pprint-exit-if-list-exhausted)
	    (write-char #\Space)
	    (pprint-newline :linear)))
    (pprint-indent :block 2)
    (pprint-newline :mandatory)
    (write (term-of form))))

(def-pretty-print binding (form)
  (pprint-logical-block (*standard-output* nil :prefix "(" :suffix ")")
    (write (var-of form))
    (write-char #\Space)
    (write (value-of form))
    (write-char #\Space)
    (write (type-of form))))

(def-pretty-print bind (form)
  (pprint-logical-block (*standard-output* nil :prefix "(" :suffix ")")
    (write 'bind)
    (write-char #\Space)
    (pprint-logical-block (*standard-output* (bindings-of form)
                                             :prefix "(" :suffix ")")
      (loop (write (pprint-pop))
	    (pprint-exit-if-list-exhausted)
	    (write-char #\Space)
	    (pprint-newline :linear)))
    (pprint-indent :block 1)
    (pprint-newline :linear)
    (write (term-of form))))

(def-pretty-print function (form)
  (pprint-logical-block (*standard-output* nil :prefix "(" :suffix ")")
    (write 'lambda)
    (write-char #\Space)
    (write (args-of form))
    (pprint-indent :block 2)
    (pprint-newline :linear)
    (write (term-of form))))

(def-pretty-print program (form)
  (pprint-logical-block (*standard-output* nil :prefix "(" :suffix ")")
    (write 'defprogram)
    (write-char #\Space)
    (write (name-of form))
    (write-char #\Space)
    (write (args-of form))
    (pprint-indent :block 2)
    (pprint-newline :linear)
    (write (term-of form))))

(def-pretty-print universal-quantified-set (form)
  (let ((bound-vars (bound-vars-of form)))
    (pprint-logical-block (*standard-output* nil :prefix "{" :suffix "}")
      (format *standard-output* "ForAll ~S in ~S~:{, ~S in ~S~} ."
	      (first (first bound-vars)) (second (first bound-vars))
	      (rest bound-vars))
      (write-char #\Space)
      (pprint-indent :block 3)
      (loop for exp in (exprs-of form)
	    do (pprint-newline :linear)
	       (write exp)))))

